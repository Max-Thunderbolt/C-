template <class T>
struct RSHelper : public TowersOfHanoi<T>
{
public:
    RSHelper(int startTower, int goalTower) : TowersOfHanoi<T>(startTower, goalTower)
    {
    }
    void solveGame();
    void solveGameHelper(int numDisks, int startTower, int goalTower, int spareTower);
};

template <class T>
void RSHelper<T>::solveGame()
{
}

template <class T>
void RSHelper<T>::solveGameHelper(int n, int startTower, int goalTower, int spareTower)
{
    /*
    This function is a helper function for the recursive solution.
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    This function takes in the parameters needed to solve the Towers of Hanoi problem recursively.
    n: the number of disks to be moved
    startTower: the tower that the disks are initially on
    goalTower: the tower that the disks are to be moved to
    tempTower: the tower that is used as a temporary tower to move the disks
    */

    if (n == 1)
    {
        // move the disk from the start tower to the goal tower
        this->moveDisk(startTower, goalTower);
    }
    else if (n == 0)
    {
        cout << "no more disks to move" << endl;
    }
    else
    {
        cout << "n: " << n << endl;
        // move the top n-1 disks from the start tower to the temp tower
        solveGameHelper(n - 1, startTower, spareTower, goalTower);
        cout << "about to move disk" << endl;
        // move the bottom disk from the start tower to the goal tower
        this->moveDisk(startTower, goalTower);
        cout << "moved disk" << endl;
        // move the top n-1 disks from the temp tower to the goal tower
        solveGameHelper(n - 1, spareTower, goalTower, startTower);
        
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
COUNT() helpers: 

template <class T>
int diskIterator(int remainder, int currNumTowers, T *labelPtr)
{
    stack<Disk<T> *> currentTower = TowersOfHanoi<T>::getTower(remainder);
    if (currentTower.empty())
    {
        return 0;
    }
    else
    {
        T topDisk = currentTower.top()->getLabel();
        currentTower.pop();

        if (labelPtr)
        {
            if (*labelPtr == topDisk)
            {
                currNumTowers++;
            }
            diskIterator(remainder, currNumTowers, labelPtr);
        }
        else
        {
            currNumTowers++;
            currNumTowers = diskIterator(remainder, currNumTowers, labelPtr);
        }
        TowersOfHanoi<T>::addDisk(topDisk, remainder);
    }
    return currNumTowers;
}

template <class T>
int towerIterator(int remainder, int count, T *labelPtr)
{
    if (remainder == 0)
    {
        return 0;
    }
    else
    {
        int currNumTowers = 0;
        count += diskIterator(remainder, currNumTowers, labelPtr);
        towerIterator(remainder - 1, count, labelPtr);
    }
    return count;
}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
old count()

template <class T>
int RecursiveSolution<T>::count()
{
    // This function recursively counts the number of disks in the game.
    stack<Disk<T> *> *tempT1 = TowersOfHanoi<T>::getTower(1);
    stack<Disk<T> *> *tempT2 = TowersOfHanoi<T>::getTower(2);
    stack<Disk<T> *> *tempT3 = TowersOfHanoi<T>::getTower(3);

    if (tempT1->empty() && tempT2->empty() && tempT3->empty())
    {
        return 0;
    }
    else
    {
        if (!tempT1->empty())
        {
            tempT1->pop();
            return 1 + count();
        }
        else if (!tempT2->empty())
        {
            tempT2->pop();
            return 1 + count();
        }
        else if (!tempT3->empty())
        {
            tempT3->pop();
            return 1 + count();
        }
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
Solver() 

 int start = this->startTower;
    int goal = this->goalTower;
    int aux = 0;

    if (this->startTower == 1 && this->goalTower == 2)
    {
        aux = 3;
    }
    else if (this->startTower == 1 && this->goalTower == 3)
    {
        aux = 2;
    }
    else if (this->startTower == 2 && this->goalTower == 1)
    {
        aux = 3;
    }
    else if (this->startTower == 2 && this->goalTower == 3)
    {
        aux = 1;
    }
    else if (this->startTower == 3 && this->goalTower == 1)
    {
        aux = 2;
    }
    else if (this->startTower == 3 && this->goalTower == 2)
    {
        aux = 1;
    }

    stack<Disk<T> *> *tempT1 = TowersOfHanoi<T>::getTower(start);
    stack<Disk<T> *> *tempT2 = TowersOfHanoi<T>::getTower(aux);
    stack<Disk<T> *> *tempT3 = TowersOfHanoi<T>::getTower(goal);

    TowersOfHanoi<T>::validateGame();
    if (TowersOfHanoi<T>::validateGame() == 0)
    {
        try
        {
            throw *Exception<T>::invalidGame();
        }
        catch (Exception<T> &e)
        {
            cout << e.message << endl;
        }
    }
    else
    {

        cout << "recursiveSolve() tower 1 size: " << tempT1->size() << endl;
        T valT1 = 0;
        T valT2 = 0;
        T valT3 = 0;

        if (!tempT1->empty())
        {
            valT1 = tempT1->top()->getLabel();
        }

        if (!tempT2->empty())
        {
            valT2 = tempT2->top()->getLabel();
        }

        if (!tempT3->empty())
        {
            valT3 = tempT3->top()->getLabel();
        }

        step = moves % 3;

        if (count % 2 == 0)
        {
            switch (step)
            {
            // Step 1
            case 0:
                if (valT1 < valT2 && valT1 != 0 || valT2 == 0) // (1 -> 2)
                {
                    TowersOfHanoi<T>::moveDisk(start, aux);
                    moves++;
                    valT2 = valT1;
                }
                else // (2 -> 1)
                {
                    TowersOfHanoi<T>::moveDisk(aux, start);
                    moves++;
                }
                cout << "moves: " << moves << endl;
                return moves;
                recursiveSolve(moves, step, count);

            // Step 2
            case 1:
                if (valT1 < valT3 && valT1 != 0 || valT3 == 0) // (1 -> 3)
                {
                    TowersOfHanoi<T>::moveDisk(start, goal);
                    moves++;
                    valT3 = valT1;
                }
                else // (3 -> 1)
                {
                    TowersOfHanoi<T>::moveDisk(goal, start);
                    moves++;
                }
                cout << "moves: " << moves << endl;
                return moves;
                recursiveSolve(moves, step, count);

            // Step 3
            case 2:
                if (valT2 < valT3 && valT2 != 0 || valT3 == 0) // (2 -> 3)
                {
                    TowersOfHanoi<T>::moveDisk(aux, goal);
                    moves++;
                    valT3 = valT2;
                }
                else // (3 -> 2)
                {
                    TowersOfHanoi<T>::moveDisk(goal, aux);
                    moves++;
                }
                cout << "moves: " << moves << endl;
                return moves;
                recursiveSolve(moves, step, count);
            }
        }
        else
        {
            step = moves % 3;
            switch (step)
            {
            // Step 1
            case 0:
                if (valT1 < valT3 && valT1 != 0 || valT3 == 0) // (1 -> 3)
                {
                    TowersOfHanoi<T>::moveDisk(start, goal);
                    moves++;
                    valT3 = valT1;
                }
                else // (3 -> 1)
                {
                    TowersOfHanoi<T>::moveDisk(goal, start);
                    moves++;
                }
                cout << "moves: " << moves << endl;
                return moves;
                recursiveSolve(moves, step, count);

            // Step 2
            case 1:
                if (valT1 < valT2 && valT1 != 0 || valT2 == 0) // (1 -> 2)
                {
                    TowersOfHanoi<T>::moveDisk(start, aux);
                    moves++;
                    valT2 = valT1;
                }
                else // (2 -> 1)
                {
                    TowersOfHanoi<T>::moveDisk(aux, start);
                    moves++;
                }
                cout << "moves: " << moves << endl;
                return moves;
                recursiveSolve(moves, step, count);

            // Step 3
            case 2:
                if (valT2 < valT3 && valT2 != 0 || valT3 == 0) // (2 -> 3)
                {
                    TowersOfHanoi<T>::moveDisk(aux, goal);
                    moves++;
                    valT3 = valT2;
                }
                else // (3 -> 2)
                {
                    TowersOfHanoi<T>::moveDisk(goal, start);
                    moves++;
                }
                return moves;
                recursiveSolve(moves, step, count);
            }
        }
    }
    return moves;